### fs 模块

+ fs 模块：是 Node.js 内置的模块；fs (file system 文件系统) 用于文件读写；

```javascript
let fs = require('fs');

// 1. 异步读取文件:
// __dirname 当前文件所处的路径，绝对路径
// __filename 当前文件的带绝对路径的文件名，并且带扩展名

// fs.readFile(带路径的文件名, 编码, callback) 
fs.readFile('./1.txt', 'utf8', (err, data) => {
  // 如果读取成功 err 是 null，如果读取失败 err 是对象；
  // 如果文件读取成功，会把读到的数据传给 data，在回调函数中使用这个 data 就是使用读取来的数据；
  if (err) {
    // console.log(err);
    // no such file or directory 没有这样一个文件或者文件夹；（导致报错的原因就是文件路径错误）
  } else {
    // console.log(data);
  }
});

// 2. 同步读取文件：
// fs.readFileSync(带路径的文件名, 编码)
// 返回值是读取到内容；
// let data = fs.readFileSync('./1.txt', 'utf8');
// console.log(data);

// 修改文件：向文件中写入内容

// 3. 异步写入文件
// fs.writeFile(path, data, option, callback);
// path 文件名（如果没有这个文件会创建一个）
// data 要写入文件的内容
// option 文件编码
// callback 写入后执行的回调

let code = 'function sum (a, b) {return a + b}';
fs.writeFile('./a.js', code, 'utf8', (err, data) => {
  // err 写入失败时是一个对象，写入成功是 null
  if (err) {
    console.log('写入失败');
    // 一般写入文件失败是由于文件夹权限有问题
  } else {
    // console.log('写入成功');
  }
});

// fs.writeFile() 是覆盖式写入，原文件中的内容会被覆盖掉；如果要追加的话，先把原来的文件内容读取出来，然后再拼接上咱们要写入的内容，然后再一并写回去；

// 同步写入：
// fs.writeFileSync(path, data, option)
// path 文件名（含路径）
// data 写入文件的内容
// option 编码
// 同步写入没有返回值
let htmlStr = `<!DOCTYPE>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="发上等愿，结中等缘，享下等福">
  <meta name="keywords" content="前端好,前端好个锤子">
  <title>这是一个title标签</title>
  <!--TDK 做SEO时要设置-->
</head>
<body>
  <div>
    这是一个划时代的app 
 </div>
</body>

<script>
alert('真香')
</script>
</html>`;

let wdata = fs.writeFileSync('../a.html', htmlStr, 'utf8');
console.log(wdata);

// 向文件中追加内容：

// 异步追加
// fs.appendFile(path, data, option, callback)
// path 文件名（含路径）
// data 写入文件的内容
// option 编码
// callback 追加后的回调

let code2 = '\n\rfunction minus(a, b) {return a - b}';
// \n 换行
// \n\r 空行
/*fs.appendFile('./b.js', code2, 'utf8', (err, data) => {
  if (err) {
    console.log(err);
  } else {
    console.log('追加成功');
  }
});*/

// 同步追加
// fs.appendFileSync(path, data, option)
// 参数和异步相同
fs.appendFileSync('./b.js', code2, 'utf8');
```

### yarn

```javascript
// npm install 依赖包名 参数
// npm install 或者 npm i

// yarn 包管理器
// yarn 等效于 npm install 按照 package.json 安装依赖
// yarn add 依赖包名 --save 安装生产依赖
// yarn add 依赖包名 --dev 安装开发依赖
// yarn remove 依赖包 卸载依赖包 等效于 npm uninstall 依赖包
```

### http 模块

+ http 模块： http 是 Node.js 的内置模块；是用来处理客户端的 http 请求的；

```javascript
// 前端：发起请求，获取数据，然后拿到数据渲染到页面中

// 后端（服务端）：响应请求，发送数据；

// 前后端通过 http 协议通信，前端通过 http 发请求，向服务器要数据；服务端处理 http 请求，通过 http 协议向客户端发送数据；

let http = require('http');
let fs = require('fs');

// 1. 处理客户端 http 请求，首先要创建一个服务；
// http.createServer() 创建一个服务
let server = http.createServer(function (request, response) {
  // 具体的处理 http 请求的代码要写在这个回调函数中；只要客户端发送一个 http 请求，这个回调函数就会执行一次；
  // request 请求对象 这个对象中包含了客户端的请求中所有的信息；
  // response 响应对象 这个对象中包含了所有用来响应客户端所需要的方法和属性；

  console.log('请求来了');

  // 把 index.html 响应给客户端
  // 首先我们需要把 index.html 读出来，然后把读取的结果作为响应内容发送给客户端；
  fs.readFile(__dirname + '/index.html', (err, data) => {
    if (err) {
      response.end('读取失败')
    } else {
      response.end(data); // 向客户端发送响应数据
    }
  });

  // 我们在响应客户端请求的时候，现在并没有判断客户端请求的是什么；当客户端收到 index.html 以后会解析 html，解析的时候遇到 script 标签，而 script 会再向服务器发送请求，而此时我们的服务只会响应 index.html 的内容，所以 script 收到的就是 index.html 的内容；
});

// 2. 服务还需要监听端口号（练习阶段不要使用3000以下）
// 端口的范围：0-65535
// server.listen(端口号, 监听端口成功执行的回调)
server.listen(8000, () => console.log('port 8000 is on'));
// 一个端口只能供一个服务监听，当前8000端口被 server 占用了，其他的服务就不能再用8000端口了；


// 写完脚本以后，还需要到命令行里面启动这个服务：node 文件名
// 去浏览器中访问：localhost:8000
// 为什么用localhost？因为正常的请求是访问 url，然后 DNS 负责把 url 解析成 ip 地址，然后请求 ip 地址；但是服务是运行在咱们的本地，本地的 ip 127.0.0.1, 而 127.0.0.1 就是 localhost

// 此时我们的电脑上既运行着客户端又运行着服务端；浏览器是客户端，用 node 启动的 js 脚本是服务端；

// 修改了服务端的程序需要重启 server
```

### url 模块

```javascript
// url 模块也是 Node.js 的内置模块，是用来解析 url 的；
let http = require('http');
let url = require('url');
let fs = require('fs');

// 1. 创建一个服务
let server = http.createServer((req, res) => {
  // console.log(req.url); 客户端请求的 url
  // console.log(req.headers.cookie); 客户端带来的 cookie

  let urlObj = url.parse(req.url, true); // url.parse() 解析请求 url 的方法，第二个参数传 true，把 url 问号传参格式化成一个对象，并在挂载在 query 属性上
  console.log(urlObj);
  // pathname 客户端请求的路径
  // search 客户端问号传参的内容（带问号）
  // query 客户端传递的查询字符串
});

// 2. 监听端口号
server.listen(8000, () => console.log('port 8000 is on'));
```
