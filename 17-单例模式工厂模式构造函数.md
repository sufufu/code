### 单例模式 高级单例

```javascript
var stu1 = {
  name: '张奎',
  age: 18,
  sex: 'boy',
  address: '**'
};

var stu2 = {
  name: '肖泽辉',
  age: 15,
  sex: 'boy',
  address: '河北省'
};

// 单例模式：像上面这种把描述一个对象的属性放到一个对象中，这种封装方式称为单例模式。stu1 和 stu2 代表的这两个对象称为单例，stu1.name 和 stu2.name 没有关系，不会互相覆盖。因为这两个对象是两个不同的堆内存空间。stu1 和 stu2 这两个变量名称为命名空间（namespace）

// 高级单例模式：不是直接将一个对象赋值给变量名，而是在等号右侧写一个自执行函数，在自执行函数末尾返回一个对象；这样写有一个优势，我们可以选择哪些给外面用，哪些不给外面用；另一个优势就是代码很简洁。

var stu3 = (function () {
  var name = '马宾';
  var age = 19;
  var sex = 'boy';
  var address = '河北涞水';
  return {
    name: name,
    address,
    // age: age,
    age, // ES6 对象语法：属性名和变量名同名时，写一个变量名就可以代表属性名是变量名属性值是变量代表的值；age: age
    sex: sex
  }
})();

```

单例模式解决了全局变量命名冲突、互相覆盖的问题。但是效率很低，不能批量的创建对象；有没有简单方式可以实现批量生产呢？

### 工厂模式

```javascript
// 单例模式创建老师的信息记录对象
let t1 = {
    name: '马宾',
    age: 18,
    subject: 'JS',
    from: '珠峰'
};
let t2 = {
    name: '姜文',
    age: 16,
    subject: '珠峰架构课程',
    from: '珠峰'
};

// 单例模式虽然解决了全局变量命名空间互相覆盖的问题，但是效率太低，当大规模创建对象时就需要些许多重复的代码。怎么解决这个问题

// 工厂模式

function teacher(name, age, subject, from = '珠峰') {
    var obj = {} // 原材料
    obj.name = name; // 加工
    obj.age = age;
    obj.subject = subject;
    obj.from = from;
    obj.teach = function () {
        console.log(`${this.name} 老师教 ${this.subject}`)
    };
    return obj // 出厂
}

var t3 = teacher('任金辉', 19, 'JS');
console.log(t3);
var t4 = teacher('薛振翔', 19, 'JS');
console.log(t4);
console.log(t3 === t4);
```
像上面这样，把创建对象的细节封装成一个函数，在函数中为这个对象添加属性，这种创建对象的模式叫做工厂模式，工厂虽然可以批量生产，但是生产出来的对象都一样，没有分类

那怎么办呢？？

### 构造函数

构造函数：构造函数也是一个函数，但是其内部实现和调用方式和普通函数不同

1. 构造函数只能用 new 来调用（用 new 调用，这个函数才叫构造函数）
2. 构造函数不需要手动创建实例对象，在通过 new 调用构造函数时，构造函数会隐式的创建一个属于这个类的实例对象，并且把构造函数中的 this 指向这个实例对象。后续的加工都在 this 上加工就可以了。
3. 构造函数不需要手动返回实例对象，构造函数在执行后会隐式的返回实例对象；

```javascript
function Teacher(name, age, subject, from) {
  this.name = name;
  this.age = age;
  this.subject = subject;
  this.from = from;
  this.teach = function () {
    console.log(`${this.name} 老师教 ${this.subject}`);
  }
}

let t1 = teacher('马宾', 18, 'JS', '珠峰'); // 工厂函数创建

let t2 = new Teacher('姜文', 19, '架构', '珠峰');
let t3 = new Teacher('马宾', 18, 'JS', '珠峰');

console.log(t1); // 得到一个普通对象，没有类的概念
console.log(t2); // 得到一个带有 Teacher 类型的实例对象
```

构造函数模式：像上面这种，把创建对象的细节封装到构造函数中。通过 this.xxx = xxx 向实例对象上添加属性。用这种方式创建对象称为构造函数模式。此时构造函数就叫做类，函数名叫类名(一般情况下类名首字母大写，如果有多个单词，使用驼峰命名法)；
通过 new 的方式调用构造函数，可以返回一个属于当前类的实例对象。这个实例对象里面的属性称为【私有属性】

```javascript
// instanceof 运算符：检测一个实例是否属于某个类型，如果属于这个类型就返回true，如果不属于就返回false

// console.log([] instanceof Array); // true
// console.log(/\d/ instanceof RegExp); // true
//
// console.log(t2 instanceof Teacher); // true
// console.log(t2 instanceof Object); // true
// console.log([] instanceof Object); // true
console.log(/\d+/ instanceof Object); // true
// Object 是js中的基类（基础类型），其他的类都有Object的属性和特点。所以用instanceof检测实例是否是Object的实例时，都会返回true；
```

构造函数虽然解决了工厂函数没有类型的问题，但是相比较 Array 内置类，我们自定义的类 Teacher 没办法让共有的属性和方法共有，而是每个实例都自己有一份。例如 t2 和 t3 都是老师类的实例，而只要是老师就应该会 teach（教学），说明 teach 是老师类共有的属性，但是构造函数 Teacher 却没办法实现？