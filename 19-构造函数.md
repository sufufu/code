### new 调用和普通调用的区别

普通函数执行机制：
1. 开辟私有作用域
2. 形参赋值
3. 变量提升
4. 代码执行
5. 销毁栈内存（特殊情况除外）

new 构造函数执行
1. 开辟作用域
2. 形参赋值
3. 变量提升
4. 隐式创建一个属于当前这个类的实例对选哪个，然后把构造函数中的 this 指向这个实例对象
5. 执行构造函数中的代码；如果 this.xxx = xxx; 就是给实例添加私有属性。
6. 隐式返回这个实例对象，相当于 return this
7. 销毁栈内存（构造函数的作用域销毁与否和普通函数一样）

构造函数中的this，指向当前构造函数的实例对象；

### 构造函数显示设置返回值

```javascript
/*
* 目标：
*   1. 理解给构造函数设置返回基本数据类型的返回值和引用数据类型的返回值的区别；
*   2. 不要随意指定构造函数的返回值
* */

function Teacher(name, age, subject, from) {
  this.name = name;
  this.age = age;
  this.subject = subject;
  this.from = from;
  this.teach = function () {
    console.log(`${this.name} 老师教 ${this.subject}`);
  };
  // return 1;
  // return [1, 2]
  // return this; this 就是这个类的实例，显示的 return this 并不会带来什么影响；
}

let mrJiang = new Teacher('姜文', 19, '架构', '珠峰');
console.log(mrJiang);
console.log(mrJiang instanceof Teacher); // true

// 1. return 基本数据类型: 构造函数不受影响，仍然正常返回实例。
// 2. return 引用数据类型：构造函数隐式返回的实例就会被 return 的这个引用数据类型的值所覆盖，并且返回的值也不再是该类型的实例了。

// !不要随意在构造函数中指定返回值；
```

### 原型模式

```javascript
// 只要属于数组类，就可以 push、pop、slice。但是数组实例中并没有这些属性，这是因为内置 Array 类，它把数组类共有的属性实现了共有。所以我们的自定义的 Teacher 类也应该把 teach 方法共有了。但是有一个问题，这个方法放在哪儿，可以实现共有？

// 改造Teacher类
function Teacher(name, age, subject, from) {
  this.name = name;
  this.age = age;
  this.subject = subject;
  this.from = from;
}

Teacher.prototype.teach = function () {
  console.log(`${this.name} 老师教 ${this.subject} 学科`);
};
let mrMa = new Teacher('马宾', 18, 'JS', '珠峰');
let mrJiang = new Teacher('姜文', 19, '架构', '珠峰');
let mrRen = new Teacher('任金辉', 19, 'JS', '珠峰');
mrMa.teach();
mrJiang.teach();
mrRen.teach();
console.log(mrMa.teach === mrJiang.teach);
console.log(mrJiang.teach === mrRen.teach);


// prototype（原型）对象：每个函数（普通函数、构造函数【类】）都天生自带一个属性 prototype（原型），它的值是一个对象，用来存储这个类共有的属性和方法。存储在 prototype 上的属性和方法称为公有属性和方法；

// 基于构造函数的原型模式：把这个类共有的属性和方法放在 prototype（原型）对象中。这样做可以实现只要是这个类实例，就能够使用这些方法或者属性；这样做解决了共有属性和方法共有的问题。

console.log(Teacher.prototype);
console.log(Teacher.prototype.constructor === Teacher); // true

// prototype对象上天生自带一个 constructor 属性，它的值就是构造函数本身；或者说 prototype 对象的 constructor 属性指向 Teacher 构造函数；
/*
* {
*   teach: function ....,
*   constructor: Teacher 构造函数
* }
* */

// ? 为什么我们把 teach 方法搬到 Teacher.prototype 对象里面了，但是 Teacher 的实例还可以调用这个方法？为啥？
console.log(mrRen);
console.log(mrJiang);
// 经过查看，mrRen 和 mrJiang 这两个实例里面没有 teach 私有属性，但是我们发现 __proto__ 属性，这个属性值是一个对象，在这个对象中有我们需要的 teach 方法。

// 如果直接访问一个对象不存在的属性，会得到一个 undefined。但是我们访问 mrRen、mrJjiang 的 teach 属性时得到了 teach 方法，所以一定有机制可以让它找到 teach 方法。
```

### 原型链

原型（prototype）链：是对象的属性查找机制。
+ 当我们访问一个实例对象的属性时，浏览器会首先在实例对象的私有属性中查找，如果找到就使用这个私有属性，如果没找到，通过实例对象 __proto__ 属性去当前实例对象所属类的 prototype（原型）上查找，如果在原型的公有属性中找到这个属性，就使用这个公有的属性。如果找不到，就通过 prototype（原型）对象继续向上查找，一直找到基类 Object 的原型上，如果还没找到，就返回 undefined

```javascript
function Teacher(name, age, subject, from) {
  this.name = name;
  this.age = age;
  this.subject = subject;
  this.from = from;
}

Teacher.prototype.teach = function () {
  console.log(`${this.name} 老师教 ${this.subject} 学科`);
};
let mrMa = new Teacher('马宾', 18, 'JS', '珠峰'); // 实例对象是new Teacher() 执行的返回值
let mrJiang = new Teacher('姜文', 19, '架构', '珠峰');

console.log(mrJiang);
console.log(mrMa);
mrMa.teach();
mrJiang.teach();
// console.log(mrMa.address); // undefined
console.log(mrMa.__proto__ === Teacher.prototype);
console.log(mrMa.__proto__.__proto__ === Object.prototype);
console.log(Teacher.prototype.__proto__ === Object.prototype);
// console.log(Object.prototype);
```