### 变量提升

/*
* 变量提升（预解释、预处理）：在 js 代码执行之前，浏览器会对所有带 var 和 function 的进行提前的声明或者定义；
* 声明（declaration）：声明一个变量，告诉浏览器有这么一个变量；
* 定义（define）：给变量赋值；
* 对带 var 的变量只声明不定义，变量声明后不定义其默认值是 undefined；
* 对带 function 的变量（函数名），声明并且定义；
*
* 完成变量提升后，js代码才会从上到下执行。
* 在执行到 var 变量 = 值；才会对带var的变量进行赋值操作，也就是说经过这一行之后变量才代表这个具体的值，在此之前变量的值是 undefined。
* 在执行到 function 函数名() {....} 浏览器会忽略这些函数定义代码，因为在变量提升阶段已经对函数名定义过了，所以不会重复定义。
*
* 所以，在普通变量赋值之前使用就是 undefined，赋值之后才是具体值；
* 而 function 声明的函数名在声明前使用时函数本身，在声明后使用还是函数本身。
* */

```javascript

// js代码的运行机制：
var num = 100;
console.log(num);
var obj = {
  name: '珠峰'
};
function fe(name) {
  var age = 10;
  console.log(name + ' from zhufeng');
}

fe('马宾');
fe('崔晋东');
/*
* js的运行机制：
* 1. js 代码执行之前，浏览器会为其开辟全局作用域，然后对全局中的变量进行提升操作，对带 var 和带 function 进行提前的声明或者定义；
* 2. 变量提升结束后，js 代码开始从上到下执行；执行的过程中对带 var 的变量进行赋值：
*   2.1 如果是赋值一个基本数据类型的值，那么直接把基本类型的值存在作用域中，并且把变量和值关联起来；
*   2.3 如果是赋值一个引用数据类型，浏览器会开辟一个堆内存，存储这个引用数类型的值，然后把这个堆内存的地址赋值给变量（这个时候这个内存地址是存在作用域中的）
* 3. 如果执行过程遇到函数执行会经历以下几步：
*   1. 浏览器会函数代码执行再开辟一个新的作用域（一块新的栈内存）（这解释函数每次执行都是互相独立的，因为每次执行的环境不同）
*   2. 形参赋值，形参也是变量，把函数执行时实参赋值给形参。
*   3. 私有作用域中的变量提升，对私有作用域中的带 var 和带 function 的提前处理（在当前作用域中变量提升）
*   4. 从上到下执行函数代码
* 4. 如果再遇到函数执行重复第三步
* */
```

### 补充

#### 重复声明

变量多次声明时，浏览器不会多次声明，只会声明一次

```javascript
// ?? fe 打印出来是什么？
console.log(fe);

var fe = '123';
console.log(fe); // '123'
// fe(); // Uncaught TypeError: fe is not a function 【未能捕获的类型错误：fe 不是一个函数】

function fe() {
  console.log('FE from zhufengpeixun');
}
// 当函数名和变量重名时，函数的优先级比变量的优先级高。在变量提升阶段，变量名只会声明一次，但是 var fe 先得到undefined，接着因为函数又要赋值，所以 fe 这个变量就被赋值成了函数。所以只要不执行 var fe = '123'时，fe 一直就代表函数。一旦执行过 var fe = '123'，接下来 fe 就代表 '123'
```

#### 细节问题

1. 等号右侧不会变量提升，即使是函数也不行；用函数表达式创建的函数，必须在赋值之后才能使用
2. 条件语句中的变量提升，不管条件成立与否，都会进行变量提升
3. return 下面的代码虽然不执行，但是仍然会变量提升
4. 函数 return 右边的值不会进行变量提升，即使是函数也不行(函数的返回值不会发生变量提升)

#### 带 var 和不带 var 的区别

1. 在全局作用域中用var和function声明的变量，相当于为window上增加了一个同名属性；
2. in 运算符：检测一个对象中是否有某个属性，如果有返回true，没有就返回false；
3. 带 var 和不带 var: 带 var 的是变量，会变量提升，不带 var 的不是变量。带 var 的在赋值之前使用不会报错，只不过值 undefined；不带 var 不能在赋值之前使用，使用就会报错。

#### 作用域链

```javascript
// 作用域（scope）：js 代码执行的执行的环境，另外还可以存储基本数据类型的值。
// 全局作用域：打开一个页面的时候，浏览器就会创建一个全局作用域（window对象）
// 私有作用域（函数作用域）：函数执行的时候浏览器开辟的，只要函数执行就会新开辟一个私有作用域；
// 块级作用域：把代码块（if / for 循环...的代码块变成作用域），功能和私有作用域类似，是 ES6 新增的；

// ? 如何确定上级作用域？
// 如何确定上级作用域：看这个函数在哪个作用域定义的，定义时所在的作用域，就是该函数的上级作用域
```

作用域链：变量的查找机制；当我们引用一个变量时，浏览器会首先在当前作用域中查找，看当前作用域中是否有这样一个变量，如果有直接使用。如果没有，就向上一级作用域查找，如果找到就使用，如果没找到，就继续向上查找，一直找到window，如果还没有，如果是引用就会报错，如果是赋值就是给 window 增加一个同名属性；

#### 变量提升 & 运算的细节

1. var 不会产生块级作用域， let 可以产生块级作用域
2. let 声明会造成暂时性死区，在 let 声明前访问变量会报错
3. 点运算符比等于运算符高
4. 变量提升也有优先级，函数声明 > arguments > 变量声明
5. 自执行函数执行时，会先进行变量 提升
6. if 后的 {} 不会产生块级作用域(不包含 let const 时)
7. var a = b = 3; 等价于 b = 3 var a = b;
8. +a 会把 a 转为数字，-a 会把 a 转换成 a 的负值（如果能转换为数字的话 否则为 NaN）
9. 字符串与任何值相加都是字符串拼接
10. typeof 一个未定义的变量时，不会报错，会造成暂时性死区；返回 undefined ，typeof 返回的都是字符串类型
11. if 条件判断中的函数不会进行变量提升，所以这样的函数在外部是不存在的
12. 使用 ++ 运算符时（不论前置还是后置）如果变量不是数字类型，会首先用 number（）转换为数字，因此：typeof str++ 等价于 tpyeof Number （str）++ 
13. 当书写代码时忘记写 ';' JavaScript 解析器会根据一定规则自动补上，所以
```javascript
return 
{
    bar: "hello"
};

等价于 
return；
{
    bar: "hello"
};
```
14. arguments 为类数组，类型为 Object 