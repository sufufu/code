### 移动端的事件

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!--写 rem 要写视口-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script>
    (function (designWidth) {
      function computedFont() {
        let winW = document.documentElement.clientWidth || document.body.clientWidth;
        document.documentElement.style.fontSize = winW / designWidth * 100 + 'px';
      }
      computedFont();
      window.addEventListener('resize', computedFont);
      window.addEventListener('orientationchange', computedFont);
    })(750);
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    html {
      font-size: 100px;
    }
    .box {
      margin: .3rem auto;
      width: 3rem;
      height: 3rem;
      background: lightgreen;
    }
  </style>
</head>
<body>
<div class="box"></div>

<script>
  // 移动端的常用事件：
  // 移动端很少用 click，因为在移动端有 300ms 延迟；
  let box = document.querySelector('.box'); // querySelector 和 querySelectorAll 在移动端随意用，但是注意没有 DOM 映射，如果元素是动态绑定的，在绑定后需要重新获取；
  
  // 1. touchstart 触摸元素时触发
  box.addEventListener('touchstart', function (e) {
    // console.log(e); // TouchEvent 触摸事件对象
    // console.log(e.touches[0]); // e.touches 中包含了触发事件时的信息，touches 是类数组，有长度有索引，所以需要[索引的方式获取]，这个里面仍然包含了触摸的一点的坐标信息clientX、clientY、pageX、pageY/ ；
    // console.log(this); // DOM2 级事件函数中的 this 仍然是绑定当前事件的元素对象
  });
  
  // 2. touchmove 手指在元素上滑动触发
  box.addEventListener('touchmove', function (e) {
    // 只要手指在元素上滑动，就会触发 touchmove 事件，并且触摸的点的坐标信息也会实时改变；
    // console.log(e);
    // console.log('move');
  });
  
  // 3. touchend 当手指从元素上离开时触发
  box.addEventListener('touchend', function (e) {
    // 在 touchend 事件中，e.touches 里面没有东西了。这些事件信息都去哪儿了？
    // touchend 的时候事件信息存在 e.changedTouches
    console.log(e.touches); // 空的类数组
    console.log(e.changedTouches[0]); // changedTouches 是一个类数组
    console.log('end');
  });

</script>
</body>
</html>
```

### 案例

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Title</title>
  <script>
    (function (designWidth) {
      function computedFont() {
        let winW = document.documentElement.clientWidth || document.body.clientWidth;
        document.documentElement.style.fontSize = winW / designWidth * 100 + 'px';
      }
      computedFont();
      window.addEventListener('resize', computedFont);
      window.addEventListener('orientationchange', computedFont);
    })(750);
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    html {
      font-size: 100px;
    }
    .box {
      margin: .3rem auto;
      width: 3rem;
      height: 3rem;
      background: lightcoral;
      opacity: .3;
      /*transition: all .5s linear 0s;*/
    }
  </style>
</head>
<body>
<div class="box"></div>

<script>
  // 如果在盒子的 x 或者 y 方向上手指滑动的距离超过 30px，就把这个盒子的 opacity 的值设为1，否则就让盒子旋转 540 度；
  let box = document.querySelector('.box');

  // 思路：在触摸元素时，记录下触摸点的初始位置坐标；监听元素 touchmove 事件，在移动时会不断的触发 touchmove 事件，并且可以通过事件对象获取当前手指所处的位置坐标，用当前的位置减去起始位置判断手指头移动的距离是否超过 30px，并且把是否超过30的结果保存起来；当手指头离开元素时，即 touchend 触发时，要根据是否移动了 30px，做不同的操作；

  box.addEventListener('touchstart', function (e) {
    // e.touches[0].clientX
    // e.touches[0].clientY
    let {touches: {0: {clientX, clientY}}} = e;
    // 通过自定义属性
    this.startX = clientX;
    this.startY = clientY;
    this.greaterThan30 = false;

    this.style.transition = 'all 0s'; // 0s 来取消过渡效果
    this.style.transform = 'rotate(0)';
  });
  box.addEventListener('touchmove', function (e) {
    // 获取滑动后手指头的当前位置
    console.log('move');
    let {touches: {0: {clientX, clientY}}} = e;
    // 计算移动的距离是否超过 30px
    let moveX = Math.abs(clientX - this.startX) > 30;
    let moveY = Math.abs(clientY - this.startY) > 30;
    // 保存是否大于30的结果
    this.greaterThan30 = moveX || moveY; // 只要有一个方向大于30就可以
    // 直接触摸元素然后手指离开并不会触发 touchmove 事件，导致 greaterThan30 是上一次的结果，所以我们每次在触摸开始时把该属性置为false；
  });
  
  box.addEventListener('touchend', function (e) {
    this.style.transition = 'all .5s linear 0s';
    if (this.greaterThan30) {
      // console.log('大于30');
      this.style.opacity = 1;
    } else {
      // console.log('小于30');
      this.style.transform = 'rotate(540deg)';
    }
  });

</script>
</body>
</html>
```