### 多种模式

单例模式、高级单例模式：解决了全局变量互相覆盖的问题，把描述事物的属性放到一个对象中，这个对象叫做单例（单独的实例），对象对应的变量名叫做命名空间
不足：创建对象的效率太低，不能实现批量生产

工厂模式：封装了创建对象的细节，成为一个函数，当我们需要创建一个对象时就执行一次这个函数
不足：工厂模式没有类型的概念

构造函数：构造函数也是函数，调用方式是通过 new 调用。它同样把创建对象的细节封装到构造函数中
1. 构造函数名要用大驼峰命名法(CamelCase)
2. 不需要显示手动创建对象，构造函数会隐式帮我们创建
3. 加工 this
4. 不需要显示返回实例
不足：不能把属于这个类共有的属性和方法共有。 this.xxx = xxx 的方式吧属性都添加到了实例上，而每个对象都是一个单独对象，这些对象之间无法共享属性和方法

原型模式：把属于这个类型的公有的属性和方法存储到原型（prototype）。
原型对象（prototype）：每个函数都有一个 prototype 的属性，它的值是一个对象，存放类的公有的属性和方法；

```javascript
function Teacher(name, age, subject, from = '珠峰') {
  this.name = name; // this.xxx = xxx 是在给实例添加私有属性
  this.age = age;
  this.subject = subject;
  this.from = from;
}
Teacher.prototype.teach = function () {
  // console.log(`${this.name} 老师教 ${this.subject} 学科`);
};
var t2 = new Teacher('马宾', 18, 'JS');
var t3 = new Teacher('姜文', 19, '架构');

t2.teach();
t3.teach();
// console.log(t2.teach === t3.teach); // true
// console.log(Teacher.prototype);
// console.log(Teacher.prototype.constructor);
// console.log(t2.__proto__ === Teacher.prototype);
```

#### 总结

类：类都是一个函数数据类型，每个类都有一个原型（prototype）
原型（prototype）：每个类的 prototype 都是对象，并且有一个特殊的属性 constructor，它的值指向当前类的构造函数本身
对象：（实例对象、原型(prototype)对象、函数对象..）都有一个特殊的属性 __proto__，它的值指向当前对象（实例对象、原型对象、函数对象...）所属类的原型(prototype);

如何检测一个属性是私有属性还是公有属性？？
hasOwnProperty() 用来检测一个属性时是否是这个对象的私有属性，如果是私有属性返回 true，如果不是返回 false

var f1 = new Fn; // new 调用构造函数不需要传参时后面的小括号可以省略；

#### 多态

多态：重写和重载
重写：子类可以重写父类的属性和方法
重载：有多个同名函数，但是这些函数的参数（签名）不同；当传不同参数时，会自动调用不同函数执行；JS 中没有真正的重载，但是这个功能可以模拟，传不同的参做不同的事

```javascript
function sum(int a, int b) { // 参数：数字 a , 数字 b
  return a + b;
}
function sum(char a, char b) { // 参数：字符串 a, 字符串 b
  return Number(a) + Number(b)
}
sum(1, 2); // 如果有重载，自动调用第一个 sum
sum('10', '15'); // 如果有重载，自动调用第二个 sum

// 因为不允许声明多个同名函数，声明多个同名函数时，函数名代表最后一个函数，所以 JS 没有真正意义上的重载

// 实现一个重载：根据参数不同干不同的事
// 写一个函数，如果只传一个参数，返回这个参数，如果传两个参数就给这两个参数求和；（根据参数个数重载）

function num(a, b) { // 模拟函数的重载
  if (arguments.length === 1) {
    return arguments[0];
  }
  if (arguments.length === 2) {
    return arguments[0] + arguments[1];
  }
}

// console.dir() 详细输出
```

### 内置类的原型

+ 原型（prototype）：函数都有一个 prototype 的属性，并且它的值是一个对象；如果这个函数被用来当做类（构造函数）来使用，此时 prototype 是用来存放这个类的共有属性和方法的
+ 原型链：每个对象（实例对象、prototype 对象）都有一个 __proto__ 属性。当我们 对象.属性名 时，会首先在私有属性中查找，如果私有属性没有，就通过实例的 __proto__ 去当前实例所属类的原型上查找，如果原型上还没有，就通过原型 __proto__ 继续向上查找，一直找到 Object 的原型，如果还没有就返回 undefined；

```javascript
// 1. 向原型上增加属性的方式：

// 1.1 向原型对象上增加属性和方法
/*Fn.prototype.say = function () {
  console.log('预祝各位税后25k');
};
Fn.prototype.hello = 'hello';
Fn.prototype.world = 'world';*/

var f1 = new Fn(); // {name: 'name'}

// 1.2 通过实例的 __proto__ 给原型增加属性
/*
f1.__proto__.say = function () {
  console.log('预祝各位税后25k');
};
f1.__proto__.hello = 'hello';
f1.__proto__.world = 'world';
console.log(f1);
f1.say();
*/
// 实例 __proto__ 不仅是只读的，还是可写的，所以不要轻易的修改这个属性；


// 1.3 直接将原型指向一个新对象
var obj = {
  hello: 'hello',
  world: 'world',
  say: function () {
    console.log('税后25k');
  }
};
console.log(Fn.prototype); // 修改之前的 Fn.prototype
Fn.prototype = obj;
console.log(Fn.prototype); // 修改之后的 Fn.prototype
console.log(Fn.prototype.constructor); // Object 因为我们在修改 Fn.prototype 指向 obj 时，obj 没有 constructor，所以通过 obj 的 __proto__ 找到 Object 的 prototype 拿到 Object 构造函数；
// 这种方式在修改原型指向一个新对象后，需要重新指定构造函数：
Fn.prototype.constructor = Fn; // 重新指定构造函数

var f2 = new Fn;
f2.say(); // 可以执行

// constructor 检测数据类型：
console.log([].constructor === Array); // true
console.log(/\d/.constructor === Array); // false
console.log(/\d/.constructor === RegExp); // true
// 但是，constructor 可以被修改，容易导致检测结果不准确
Array.prototype.constructor = 1;
console.log([].constructor === Array); // false 因为此时 Array.prototype.constructor 是1


// 面向过程、面向对象比较：

// 面向过程
/*var name = '张三';
var age = 18;
var job = '搬砖';

var name2 = '李斯';
var age2 = '50';
var job2 = '丞相';

function eat(name) {
  console.log(`${name} 吃饭`);
}
function drink(name) {
  console.log(`${name} 喝两口`);
}
function sleep(name) {
  console.log(`${name} 睡觉`);
}

// 张三
eat(name);
drink(name);
sleep(name);

// 李斯
eat(name2);
drink(name2);
sleep(name2);*/

// 面向对象
function Human(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}
Human.prototype.eat = function () {
  console.log(`${this.name} 吃饭`);
  return this; // this 就代表当前实例
};
Human.prototype.drink = function () {
  console.log(`${this.name} 喝两口`);
  return this;
};
Human.prototype.sleep = function () {
  console.log(`${this.name} 睡觉`);
  return this;
};

var zhangSan = new Human('张三', 18, '搬砖');
/*
zhangSan.eat();
zhangSan.drink();
zhangSan.sleep();
*/

zhangSan.eat().drink().sleep(); // 链式调用的原理就是在方法中return this；

var liSi = new Human('李斯', 50, '丞相');
/*
liSi.eat();
liSi.drink();
liSi.sleep();
*/

liSi.eat().drink().sleep();
```

### 多参数传参

```javascript
function design(website, style, color, users, cycle, request, rich) {};

function design2(options) {
  let web = options.website;
  let style = options.style;
  let color = options.color;
  let {users, cycle, request, rich} = options; // 解构赋值
}

design2({
  website: 'www.zhufengpeixun.cn',// 把多个参数放到一个对象中，可以解决这些参数的顺序问题
  style: 'zfstyle',
  color: 'blue',
  users: '学院',
  rich: true,
  request: [''],
  cycle: 2
});
```