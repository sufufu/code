
```javascript 
// 箭头函数
let sum = (a, b) => {
  return a + b;
};
// 简化语法：

// 1. 当形参只有一个时，形参入口的小括号可以不写
let ok = how => {
  return 'I am fine'
};

// 2. 当函数只有一行代码时，可以省略花括号和 return 关键字
let ok2 = how => 'I am fine';
console.log(ok2());
// 当你返回一个对象的时候要用小括号包裹
let ok3 = how => ({name: 'haha'});
console.log(ok3());

// 3. 箭头函数中没有 arguments，但是可以使用不定参数（剩余参数）；
let sum = (...arg) => {
  console.log(arg);
  console.log(Array.isArray(arg)); // true 剩余参数是一个真正的数组
};
// sum(1, 3, 4);

// 4. 不定参数：
let sum2 = (a, b, ...arg) => {
  // 此时arg表示除了a, b 剩下的实参；从第三个及以后的实参会放到 arg 中
  console.log(arg);
};
sum2(1); // arg = [] arg 是一个数组，里面没有值时是个空数组
sum2(1, 2); // arg = []
sum2(1, 2, 3); // arg = [3]
sum2(1, 2, 3, 4, 5); // arg = [3, 4, 5]

// 5. 箭头函数中没有自己的 this，所以箭头函数里面的 this 是箭头函数声明时所在作用域中的 this（上级作
// 用域中的 this）；
// arguments 和 this 是函数执行时，解析引擎传给函数的。箭头函数执行时，js 引擎没有给传。
// 所以箭头函数不能用来做构造函数；
// 箭头函数也没有自己的 prototype；
```
## 对象的操作

`let obj = new Object() // new 一个对象出来`

如何遍历对象？
```javascript
let obja = {
			name: 'aa',
			age: 16,
			hobby: '唱跳 rap 篮球'
		}
		for (let obj in obja) {
			console.log(obj);
		}
		Object.getOwnPropertyNames() // 可以遍历不可枚举属性
		object.keys()
    // 删除属性：delete obj.marry;
    // 当一个对象的属性名为变量或者数字的时候，对象就不能通过对象点属性名获取它的值；需要通过 obj[属性名] 获取
```

如果想操作对象？
```javascript
{
    value: 123; // value 是属性的属性值，默认为 undefined
		writable: false; // 表示属性值是否可改变（即是否可写），默认为 true
		enumerable: true; // 表示该属性是否可遍历 默认为 true
		configurable: false; // 表示可配置性，默认为 true 如果是 flase 表示无法删除该属性
		get: undefined; // 一个函数，代表 getter
		set: undefined; // 一个函数，代表 setter
		Object.getOwnPropertyDesctiptor(obj, 'p') // 获取属性描述对象
		Object.getOwnPropertyNames() // 返回一个数组，成员是参数对象自身的全部属性名，不管该属性是否可遍历
			
		// 注意：一旦定义了取值函数 get 或 set 就不能设置 writable 或者同时定义 vlaue 属性，否则报错

		Object.preventExtensions(obj) // 使对象无法添加新属性
		Object.isExtensible(obj) // 检查一个对象是否用了 Object.preventExensions 方法
		Object.seal(obj) // 让一个对象不能添加新属性且不能删除旧属性
		Object.isSealed(obj) // 检查一个对象有没有用 Object.seal 方法
		Object.freeze(obj) // 使一个对象不能添加不能删除不能改变属性的值，相当于常量
		Object.isFrozen(obj) // 检查一个对象有没有用 Object.freeze 方法
		obj.hasOwnProperty('p') // 检查对象里是否包含该属性
}
```



## 什么是闭包 

1. 函数执行形成私有作用域，在私有作用域中变量不受外界影响，我们称这种机制为闭包。其中最经典的情形是不销毁的栈内存，例如一个函数执行 return 一个函数。
• 开辟一个堆内存
• 把函数体中的代码当作字符串存储进去
• 把堆内存的地址赋值给函数名 / 变量名
• 函数在那创建，那么它执行时所需要查找的上级作用域就是谁

2. 函数执行
• 开辟一个栈内存
• 形参赋值 && 变量提升
• 代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
• 遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找...一直找到全局作用域为止， =》作用域链查找机制
• 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是闭包的保护机制

3. 关于堆栈内存释放问题（以谷歌 webkit 内核为例子）
函数执行就会形成栈内存（从内存中分配一块空间），如果内部都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了），堆栈内存的释放问题是学习 JS 的核心知识之一

## 什么是作用域？   

作用域分为全局作用域和私有作用域
全局作用域：当浏览器打开页面时，会形成一个供代码执行的运行环境，这个环境叫全局作用域，全局作用域一个页面只有一个，同时也会形成两个虚拟的内存，一个是栈内存，一个是堆内存

• 在全局作用域形成以后，在这个全局作用域会默认提供最大的 winidow 对象 ，当调用 window 下的方法时，window 可以省略
window.Number("20px") // 等价于  Number("20px")

私有作用域： 是给函数体中的代码提供代码的运行环境的
1. 私有作用域是在全局作用域下形成创建的；在全局作用域中包含私有的作用域
2. 全局作用域不能访问私有作用域下的私有变量，但是私有作用域能够访问全局作用下变量
3. 如果私有作用域存在该私有变量，那么就不再向外获取

栈内存                                            堆内存
提供代码的运行环境
存储基本数据类型                              存储引用数据类型值

## var的作用域   

var 声明作用于全局或函数内，声明在函数内的作用于该函数内，声明于函数外的作用于全局。（可不妨理解为叫“函数内作用域”。
```javascript
var a; // 作用于全局
{
  var b; // 作用于全局
}
function f(){
  var c; // 作用于f函数内
  {
  var d; // 作用于f函数内
  }
}
f();
```

## let的作用域     

let 和 const 均为块（大括号）作用域。变量仅在该代码块内生效，写在顶端的在全局生效。

1. let 和 const 不存在变量提升体制
• 创建变量的六种方式中，var / function 有变量提升，而 let / const / class / import 都不存在这个机制

2. var 允许重复声明，而 let 是不允许的
• 在相同的作用域中（或执行上下文）如果使用 var / function 关键词声明变量或者重复声明，是不会有影响的（声明第一次之后，之后遇到就再也不重复声明了）
• 但是使用 let / const 就不行，浏览器会校验当前作用域是否已经存在这个变量了，如果已经存在了，则再次基于 let 等重新声明就会报错
• 在浏览器开辟栈内存供代码自上而下执行之前，不仅有变量提升的操作，还有很多其他的操作， => 词法解析（词法检测）；就是检测当前即将要执行的代码是否会出现语法错误，如果出现错误，代码不会再执行（第一行都不会再执行）
• 所谓重复声明，是不管之前通过什么方法，只要当前栈内存中存在了这个变量，我们使用 let，const 再重复声明这个变量，就是语法错误

3. let 能解决 typeof 检测时出现暂时性死区问题（let 比 var 更严谨）

## 字符串

什么是字符串？
被单引号，双引号，反引号(``) 包裹的0到多个字符。是 js 中的一种基本数据类型；字符串中也有索引，索引是由浏览器分配的，同数组的索引一样；字符串还有 length 属性，length 代表字符串中的 length 的个数；我们可以通过 字符串[索引] 获取指定索引的字符；有长度 有索引就可以用 for 循环遍历

如何将字符串转换成对象？
```javascript
// 数字 字符串 布尔值 分别对应 Number String Boolean 三个类，可以通过原型上的方法把基本类型的值变成对象
let a = new String('6666'); 

valueOf() // 返回实例对应的原始类型的值
toString() // 转换为字符串

let b = str.includes("Hello", 2) // 从第2位索引值开始查找
let c = str.startsWith("Hello") // 返回布尔值 标识参数字符串是否在原字符串头部
let d = str.startsWith("World", 6) // 从第6个索引值开始查找
let e = str.endsWith("World"); // 返回布尔值 标识参数字符串是否在原字符串尾部
let f = str.endsWith("Hello", 5); // 从第5个索引值开始查找
let g = str.repeat(3) // 将字符串重复 3遍
let h = str.padStart(20, "a") // 重复第二个参数来补全 字符串 直到字符串位数为 20 在前面补全
let i = str.padEnd(20, "a") // 重复第二个参数来补全 字符串 直到字符串位数为 20 在后面补全
```