
```javascript 
// 箭头函数
let sum = (a, b) => {
  return a + b;
};
// 简化语法：

// 1. 当形参只有一个时，形参入口的小括号可以不写
let ok = how => {
  return 'I am fine'
};

// 2. 当函数只有一行代码时，可以省略花括号和 return 关键字
let ok2 = how => 'I am fine';
console.log(ok2());
// 当你返回一个对象的时候要用小括号包裹
let ok3 = how => ({name: 'haha'});
console.log(ok3());

// 3. 箭头函数中没有 arguments，但是可以使用不定参数（剩余参数）；
let sum = (...arg) => {
  console.log(arg);
  console.log(Array.isArray(arg)); // true 剩余参数是一个真正的数组
};
// sum(1, 3, 4);

// 4. 不定参数：
let sum2 = (a, b, ...arg) => {
  // 此时arg表示除了a, b 剩下的实参；从第三个及以后的实参会放到 arg 中
  console.log(arg);
};
sum2(1); // arg = [] arg 是一个数组，里面没有值时是个空数组
sum2(1, 2); // arg = []
sum2(1, 2, 3); // arg = [3]
sum2(1, 2, 3, 4, 5); // arg = [3, 4, 5]

// 5. 箭头函数中没有自己的 this，所以箭头函数里面的 this 是箭头函数声明时所在作用域中的 this（上级作
// 用域中的 this）；
// arguments 和 this 是函数执行时，解析引擎传给函数的。箭头函数执行时，js 引擎没有给传。
// 所以箭头函数不能用来做构造函数；
// 箭头函数也没有自己的 prototype；
```

## 合法属性

> style 是一个类（class），类的原型上扩展了很多方法，可以看做普通 css 属性，class 里有的属性就是合法属性，没有的就是非法属性
> 可以通过 对象.属性名 的方式

注意 ：
1. 操作 class 的时候必须使用 className 因为 class 关键字被占用了
2. 操作 style 的时候获取 xxx.style 的时候是一个对象，如果想获取到 style 里面的内容必须使用 xxx.style.xxx

## 非法属性

> 类（style）里没有的属性就是非法属性，如 hhh = width;

获取：xxx.getAttribute("属性名");
设置：xxx.setAttribute("属性名");
删除: xxx.removeAttribute（"属性名"）;

注意：合法属性可以通过点操作改变也可以通过 setAttribute 等方法改变，非法属性只能通过 setAttribute 实现

## 变量提升 & 运算的细节

1. var 不会产生块级作用域， let 可以产生块级作用域
2. let 声明会造成暂时性死区，在 let 声明前访问变量会报错
3. 点运算符比等于运算符高
4. 变量提升也有优先级，函数声明 > arguments > 变量声明
5. 自执行函数执行时，会先进行变量 提升
6. if 后的 {} 不会产生块级作用域(不包含 let const 时)
7. var a = b = 3; 等价于 b = 3 var a = b;
8. +a 会把 a 转为数字，-a 会把 a 转换成 a 的负值（如果能转换为数字的话 否则为 NaN）
9. 字符串与任何值相加都是字符串拼接
10. typeof 一个未定义的变量时，不会报错，会造成暂时性死区；返回 undefined ，typeof 返回的都是字符串类型
11. if 条件判断中的函数不会进行变量提升，所以这样的函数在外部是不存在的
12. 使用 ++ 运算符时（不论前置还是后置）如果变量不是数字类型，会首先用 number（）转换为数字，因此：typeof str++ 等价于 tpyeof Number （str）++ 
13. 当书写代码时忘记写 ';' JavaScript 解析器会根据一定规则自动补上，所以
```javascript
return 
{
    bar: "hello"
};

等价于 
return；
{
    bar: "hello"
};
```
14. arguments 为类数组，类型为 Object 

## 操作类名有几种方法？分别是？    

classList 返回所选元素的类名 是一个数组，一个类名就是一个索引
classList.add 添加一个类名
classList.remove 移除一个类名
classList.toggle 用来切换类名，有就删除，没有就添加
classList.contains 判断一个类型是不是存在，返回 true 或者 false

## this 指向函数挂载的对象

1. 事件函数中的 this 是绑定当前事件的元素
2. 自执行函数中的 this 指向 window
3. 定时器回调函数中的 this 指向 window
4. 全局作用域中的 this 是 window
5. 方法调用时，看方法名前面有没有点，有点的话，点前面是谁方法中的 this 就是谁，如果没有点，方法中的 this 就是 window
6. 箭头函数中的 this 指向声明时所在作用域中的 this
7. 构造函数中的 this 指向当前实例
8. call / apply / bind 用来修改 this 指向

## 改变this指向的几种方法？

```javascript
function sum(a, b) {
    conlole.log(this);
    conlole.log(a, b);
    return a + b;
}

var obj = {
  id: '0511120117'
};
// sum(1, 2); // window

// 1. call()
// 作用: 修改函数中的 this 指向，并且把修改 this 后的函数执行
// 语法：函数名.call(ctx, 实参1, 实参2.....)
// 参数：ctx 就是用来替换函数中this的对象，从第二个参数起，都是传递给函数的实参
// sum.call(obj, 2, 3); // call 之后，sum 中的 this 就变成了 obj

// 用 call 指定 undefined 和 null 作为 this 无效；
// sum.call(undefined, 3, 4);
// sum.call(null, 1, 3);
// sum.call();

// 2. apply()
// apply 方法和 call 方法作用一样，修改函数中的 this，并且让这个修改 this 之后的函数执行；
// 但是传参方式不同；call 方法是一个一个的传递实参给 sum 的，apply 是把实参都放到一个数组中，数组项是传递给 sum 的实参；

// sum.apply(obj, [11, 12]);
// var ary = [1, 2, 3, 4, 5];
// sum.apply(obj, ary);


// 3. bind() 方法：
// 作用：修改函数中的this，返回一个修改 this 后的新函数；不会让函数执行。
let sum2 = sum.bind(obj, 1, 2); // 传参的时候和 call 一样，需要一个一个的传
console.log(sum2);
console.log(sum === sum2); // false 因为 sum2 是一个新函数
sum2(); // 修改 this 后，需要自己执行一次这个函数

// call 和a pply 是修改 this 并且让函数执行，call 是一个一个的传参，apply 传递一个数组
// bind 是只修改 this 返回修改 this 后的新函数，并不会让函数执行；

```

## 对象的操作

`let obj = new Object() // new 一个对象出来`

如何遍历对象？
```javascript
let obja = {
			name: 'aa',
			age: 16,
			hobby: '唱跳 rap 篮球'
		}
		for (let obj in obja) {
			console.log(obj);
		}
		Object.getOwnPropertyNames() // 可以遍历不可枚举属性
		object.keys()
    // 删除属性：delete obj.marry;
    // 当一个对象的属性名为变量或者数字的时候，对象就不能通过对象点属性名获取它的值；需要通过 obj[属性名] 获取
```

如果想操作对象？
```javascript
{
    value: 123; // value 是属性的属性值，默认为 undefined
		writable: false; // 表示属性值是否可改变（即是否可写），默认为 true
		enumerable: true; // 表示该属性是否可遍历 默认为 true
		configurable: false; // 表示可配置性，默认为 true 如果是 flase 表示无法删除该属性
		get: undefined; // 一个函数，代表 getter
		set: undefined; // 一个函数，代表 setter
		Object.getOwnPropertyDesctiptor(obj, 'p') // 获取属性描述对象
		Object.getOwnPropertyNames() // 返回一个数组，成员是参数对象自身的全部属性名，不管该属性是否可遍历
			
		// 注意：一旦定义了取值函数 get 或 set 就不能设置 writable 或者同时定义 vlaue 属性，否则报错

		Object.preventExtensions(obj) // 使对象无法添加新属性
		Object.isExtensible(obj) // 检查一个对象是否用了 Object.preventExensions 方法
		Object.seal(obj) // 让一个对象不能添加新属性且不能删除旧属性
		Object.isSealed(obj) // 检查一个对象有没有用 Object.seal 方法
		Object.freeze(obj) // 使一个对象不能添加不能删除不能改变属性的值，相当于常量
		Object.isFrozen(obj) // 检查一个对象有没有用 Object.freeze 方法
		obj.hasOwnProperty('p') // 检查对象里是否包含该属性
}
```

## ES5  解析顺序

首先词法解析检查是否有语法错误，然后变量提升对带 var 和带 function 的变量进行变量提升，做完这些代码从上到下从左到右执行。
带 var 的只是提前声明（declare）“var a ” 如果只声明没有赋值，默认值是 undefined
带 function 的不仅声明，并且还定义了（defined）“a = 13”定义其实就是赋值，准确来说就是让变量和某个值进行关联。

## 什么是闭包 

1. 函数执行形成私有作用域，在私有作用域中变量不受外界影响，我们称这种机制为闭包。其中最经典的情形是不销毁的栈内存，例如一个函数执行 return 一个函数。
• 开辟一个堆内存
• 把函数体中的代码当作字符串存储进去
• 把堆内存的地址赋值给函数名 / 变量名
• 函数在那创建，那么它执行时所需要查找的上级作用域就是谁

2. 函数执行
• 开辟一个栈内存
• 形参赋值 && 变量提升
• 代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
• 遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找...一直找到全局作用域为止， =》作用域链查找机制
• 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是闭包的保护机制

3. 关于堆栈内存释放问题（以谷歌 webkit 内核为例子）
函数执行就会形成栈内存（从内存中分配一块空间），如果内部都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了），堆栈内存的释放问题是学习 JS 的核心知识之一

函数柯里化
```javascript
// 柯里化函数思想：把多参数的函数变成单参数的函数
function fn(a, b, c) {
  return a + b + c;
}
function fn1(a) {
  return function (b) { // 这种在函数中 return 函数的做法是市面中认为的闭包
    return function (c) {
      return a + b + c;
    }
  }
}
fn1(1)(2)(3);
```

## 什么是作用域？   

作用域分为全局作用域和私有作用域
全局作用域：当浏览器打开页面时，会形成一个供代码执行的运行环境，这个环境叫全局作用域，全局作用域一个页面只有一个，同时也会形成两个虚拟的内存，一个是栈内存，一个是堆内存

• 在全局作用域形成以后，在这个全局作用域会默认提供最大的 winidow 对象 ，当调用 window 下的方法时，window 可以省略
window.Number("20px") // 等价于  Number("20px")

私有作用域： 是给函数体中的代码提供代码的运行环境的
1. 私有作用域是在全局作用域下形成创建的；在全局作用域中包含私有的作用域
2. 全局作用域不能访问私有作用域下的私有变量，但是私有作用域能够访问全局作用下变量
3. 如果私有作用域存在该私有变量，那么就不再向外获取

栈内存                                            堆内存
提供代码的运行环境
存储基本数据类型                              存储引用数据类型值

## var的作用域   

var 声明作用于全局或函数内，声明在函数内的作用于该函数内，声明于函数外的作用于全局。（可不妨理解为叫“函数内作用域”。
```javascript
var a; // 作用于全局
{
  var b; // 作用于全局
}
function f(){
  var c; // 作用于f函数内
  {
  var d; // 作用于f函数内
  }
}
f();
```

## let的作用域     

let 和 const 均为块（大括号）作用域。变量仅在该代码块内生效，写在顶端的在全局生效。

1. let 和 const 不存在变量提升体制
• 创建变量的六种方式中，var / function 有变量提升，而 let / const / class / import 都不存在这个机制

2. var 允许重复声明，而 let 是不允许的
• 在相同的作用域中（或执行上下文）如果使用 var / function 关键词声明变量或者重复声明，是不会有影响的（声明第一次之后，之后遇到就再也不重复声明了）
• 但是使用 let / const 就不行，浏览器会校验当前作用域是否已经存在这个变量了，如果已经存在了，则再次基于 let 等重新声明就会报错
• 在浏览器开辟栈内存供代码自上而下执行之前，不仅有变量提升的操作，还有很多其他的操作， => 词法解析（词法检测）；就是检测当前即将要执行的代码是否会出现语法错误，如果出现错误，代码不会再执行（第一行都不会再执行）
• 所谓重复声明，是不管之前通过什么方法，只要当前栈内存中存在了这个变量，我们使用 let，const 再重复声明这个变量，就是语法错误

3. let 能解决 typeof 检测时出现暂时性死区问题（let 比 var 更严谨）

## 字符串

什么是字符串？
被单引号，双引号，反引号(``) 包裹的0到多个字符。是 js 中的一种基本数据类型；字符串中也有索引，索引是由浏览器分配的，同数组的索引一样；字符串还有 length 属性，length 代表字符串中的 length 的个数；我们可以通过 字符串[索引] 获取指定索引的字符；有长度 有索引就可以用 for 循环遍历

如何将字符串转换成对象？
```javascript
// 数字 字符串 布尔值 分别对应 Number String Boolean 三个类，可以通过原型上的方法把基本类型的值变成对象
let a = new String('6666'); 

valueOf() // 返回实例对应的原始类型的值
toString() // 转换为字符串

let b = str.includes("Hello", 2) // 从第2位索引值开始查找
let c = str.startsWith("Hello") // 返回布尔值 标识参数字符串是否在原字符串头部
let d = str.startsWith("World", 6) // 从第6个索引值开始查找
let e = str.endsWith("World"); // 返回布尔值 标识参数字符串是否在原字符串尾部
let f = str.endsWith("Hello", 5); // 从第5个索引值开始查找
let g = str.repeat(3) // 将字符串重复 3遍
let h = str.padStart(20, "a") // 重复第二个参数来补全 字符串 直到字符串位数为 20 在前面补全
let i = str.padEnd(20, "a") // 重复第二个参数来补全 字符串 直到字符串位数为 20 在后面补全
```

## ES5  解析顺序

首先词法解析检查是否有语法错误，然后变量提升对带 var 和带 function 的变量进行变量提升，做完这些代码从上到下从左到右执行。
带 var 的只是提前声明（declare）“var a ” 如果只声明没有赋值，默认值是 undefined
带 function 的不仅声明，并且还定义了（defined）“a = 13”定义其实就是赋值，准确来说就是让变量和某个值进行关联。

