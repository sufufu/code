### 根据不同请求返回不同内容

```javascript
// 根据请求的路径的不同返回不同的 html
// 获取当前的请求路径，读取路径对应的 html 然后返回给客户端即可；

let http = require('http');
let url = require('url');
let fs = require('fs');

// 1. 创建一个服务
let server = http.createServer((req, res) => {
  // 1.1 解析 url
  let urlObj = url.parse(req.url, true);
  let { pathname } = urlObj;

  // server 启动时所在的路径就是根目录 /

  // /a.html -> 读取 /a.html 文件
  // /b.html -> 读取 /b.html 文件
  // console.log('pathname is ' + pathname);
  // console.log(__dirname + pathname);
  // 当我们访问 localhost:8000 时 pathname 是 / ，此时并没有 / 的 html

  // 加一个判断，判断 pathname 是不是 /，如果是 / 就要读 index.html
  let filePath = '';
  if (pathname === '/') {
    filePath = __dirname + '/index.html'
  } else {
    filePath = __dirname + pathname;
  }

  fs.readFile(filePath, function (err, data) {
    if (err) {
      res.end('NOT FOUND')
    } else {
      res.end(data);
    }
  })
});

// 2. 监听一个端口号
server.listen(8000, () => console.log('port 8000 is on'));


// 服务端响应如 html、css、js、图片等文件服务称为静态资源服务，html、css、js 等文件称为静态资源；

// 如果 pathname 类似 /home/help/search ，这种请求路径不是具体的文件，一般都是 ajax 接口；一般都是处理动态的请求，根据客户端传递的数据返回不同的内容；
```

### 响应与 content-type

```javascript
// Content-Type:
// 服务端在响应客户端的请求的时候要设置响应内容的内容类型，即 Content-type；当客户端收到服务端的响应内容后，会按照这个 Content-type 解析响应的内容；

// Content-type 是一个响应头；

let http = require('http');
let url = require('url');
let fs = require('fs');
let contentTypes = {
  html: 'text/html',
  css: 'text/css',
  js: 'text/javascript',
  png: 'image/png',
  ico: 'image/x-icon'
};

// 1. 创建一个服务

let server = http.createServer((req, res) => {
  // 1.1 解析 url
  let urlObj = url.parse(req.url, true);
  let { pathname } = urlObj;

  // 根据 pathname 里面的拓展名，判断到底内容类型是什么；.html -> text/html; .css -> text/css
  // /a.html
  // /a.css
  // /a.js
  // /3.png
  // /
  
  let extReg = /\.(\w+)/;
  let types = extReg.exec(pathname); // 正则捕获，如果捕获到返回数组，捕获不到返回 null
  
  if (types) {
    let ext = types[1];
    console.log(ext);
    res.setHeader('Content-Type', contentTypes[ext]);
    // res.setHeader(key, value); 设置响应头信息，key 和 value 都是字符串类型的；
  }

  let filePath = '';
  if (pathname === '/') {
    res.setHeader('Content-Type', contentTypes.html);
    filePath = __dirname + '/index.html'
  } else {
    filePath = __dirname + pathname;
  }

  fs.readFile(filePath, function (err, data) {
    if (err) {
      res.end('NOT FOUND')
    } else {
      res.end(data);
    }
  })
});

// 2. 监听一个端口号
server.listen(8000, () => console.log('port 8000 is on'));

```

### MIME类型

```javascript
// MIME : 多用途互联网邮件拓展；每种文件都有自己特有的 MIME 类型，这个类型就是在响应的时候需要设置的内容类型；

// mime 依赖包，是一个第三方的模块，其中包含了绝大多数的文件的 MIME 类型；

// 使用第三方的依赖包：
// 1. 安装 mime ：yarn add mime --save
// 2. 引入第三方的模块

let mime = require('mime');
let http = require('http');
let url = require('url');
let fs = require('fs');


let server = http.createServer((req, res) => {
  // 1.1 解析 url
  let urlObj = url.parse(req.url, true);
  let { pathname } = urlObj;

  // 使用 mime 设置内容类型：mime.getType(pathname)
  // getType 方法会返回 pathname 对应的内容类型


  let filePath = '';
  if (pathname === '/') {
    filePath = __dirname + '/index.html';
    res.setHeader('Content-Type', 'text/html'); // mime.getType() 不能处理 / ；所以需要单独设置
  } else {
    filePath = __dirname + pathname;
    res.setHeader('Content-Type', mime.getType(pathname));
  }

  fs.readFile(filePath, function (err, data) {
    if (err) {
      res.end('NOT FOUND')
    } else {
      res.setHeader('set-cookie', 'name=mabin;path=/;'); // 在服务端操作 cookie；就是设置 set-cookie 的响应头
      res.end(data);
    }
  })
});

// 2. 监听一个端口号
server.listen(8000, () => console.log('port 8000 is on'));
```

### server-with-starus

```javascript
// 当用户请求的路径不存在的时候，返回状态码404，并且返回 NOT FOUND 文字；

let http = require('http');
let url = require('url');
let fs = require('fs');
let mime = require('mime');

// 1. 创建一个服务
let server = http.createServer((req, res) => {
  // 1.1 解析 url
  let urlObj = url.parse(req.url, true);
  let {pathname} = urlObj; // 获取当前请求的路径

  fs.stat(__dirname + pathname, (err, stats) => {
    // fs.stat() 方法验证路径是否存在
    // 如果路径不存在 err 就是一个对象，如果存在 err 就是 null
    if (err) {
      // 如果代码运行到这里，说明 err 是个对象；即路径不存在；
      res.statusCode = 404; // res.statusCode 是一个表示 HTTP status 的属性，通过修改这个属性，来设置 HTTP-STATUS; 404 表示请求的资源不存在；
      res.setHeader('Content-Type', 'text/plain;charset=UTF-8'); // text/plain;是普通文本的内容类型；返回汉字时要设置编码；
      res.end('你要看的页面飞了，去看看别的吧~~~')
    } else {
      // 如果代码执行到这里，说明路径有效，我们就需要返回对应的内容
      let filePath = '';

      // 因为访问 localhost:8000 时 pathname 是 / ，此时需要返回 index.html
      if (pathname === '/') {
        filePath = __dirname + '/index.html';
        res.setHeader('Content-Type', 'text/html')
      } else {
        filePath = __dirname + pathname;
        res.setHeader('Content-Type', mime.getType(pathname))
      }

      fs.readFile(filePath, (err, data) => {
        if (err) {
          res.statusCode = 500;
          res.setHeader('Content-Type', 'text/plain;charset=UTF-8');
          res.end('服务器去约会了，等会儿再来吧~~~')
        } else {
          res.end(data);
        }
      });
    }
  })

});
// 2. 监听一个端口
server.listen(8000, () => console.log('8000 port is on'));
```