### 什么是继承？

```javascript
function A() {
  // 通过 this.xxx = xxx; 方式添加的才是 A 类的实例私有的属性或者方法；
  this.text = 'A类的text';
}

A.prototype.say = function () { // 写在原型上的方法或者属性都是 A 类公有的属性和方法；
  console.log('hello world');
};

let a = new A(); // {text: '....', __proto__: ....}
console.log(a);
a.say(); // 对象.属性名 访问对象的某个属性时，首先在私有属性中查找，而私有属性中只有一个 text 属性，所以私有属性中没有 say 这个属性，接着去 a 所属类 A 的原型 A.prototype 上查找公有属性和方法，在A的原型上有一个 say 方法；此时就找到了。
// 对象.属性名 在根据原型链查找的过程中，无论是找到私有的还是公有的，只要找到就算找到，找不到返回 undefined；

function B() {}

let b = new B();
b.say(); // b 的私有属性没有 say 方法，公有属性也没有 say 方法，所以 b.say 得到 undefined，而 undefined 不能被执行，所以会报错；

// 现在我们需要让 b 能够调用到A类上的 say 这个方法；
// 我们能够让 b 调用 say 方法的前提是，say 方法要么是b的私有属性，要么是 b 的公有属性；此时我们需要继承来实现，让 B 类继承 A 类；

// 让 B 类继承 A 类，我们称 B 类为子类，A 类为父类（超类）；所谓的继承就是让子类的实例能够访问父类的属性和方法，继承就是把父类的私有属性或者公有属性变成子类的私有属性或者公有属性；
```

### 原型链继承

```javascript
// 原型链继承：把子类的原型改写成父类的一个实例；

function A() {
  this.text = 'A类的text';
}
A.prototype.say = function () {
  console.log('hello world');
};

function B() {}

// 把 B 类的原型改写成 A 类的一个实例
// console.log(B.prototype.constructor); // B
B.prototype = new A(); // {text: 'A..', __proto__: A.prototype}
// console.log(B.prototype.constructor); // A ?? 为什么变成了A？
// 因为B的原型指向了A的实例，而A的实例：{text: 'A..', __proto__: A.prototype}，所以我们B.prototype.constructor就是先在A的实例中查找constructor属性，然而并没有，接着就通过__proto__ 去A.prototype 上查找，而A.prototype上的constructor指向A。
B.prototype.constructor = B; // 原型继承要重新指定继承后的constructor

// console.log(B.prototype); // B.prototype 变成了 A 的实例

let b = new B(); // 获取 B 类的一个实例 {}

b.say(); // 'hello world'
console.log(b.text); // b.text 是B类公有的属性 'A类的text'

// 原型链继承：把父类私有和公有的属性都继承为子类的公有的属性和方法；
```

### 借用构造函数继承

```javascript
// 原型链继承是把父类的私有和公有的都变成了子类公有的。
// 我现需要把父类私有变成子类私有的；
// 借用构造函数继承，在子类的构造函数中 call 执行父类的的构造函数，此时父类是被当成一个普通函数使用的。

function A() {
  // textA 类实例私有的
  this.text = 'A类的私有的text';
}
// say 是 A 类公有的属性
A.prototype.say = function () {
  console.log('hello world');
};

function B() {
  console.log(this); // 此时 B 构造函数中的 this 是B类的实例
  A.call(this); // b 把 A 类的构造函数当成一个普通函数用 call 修改 A 内部的 this 为 B 类实例（即 B 中的 this），call 修改完 this，会让 A 执行，在 A 执行中遇到的 this.xxx = xxx ，因为 this 已经变成了 B 的实例，所以这些私有属性都被添加到了 B 的实例上
}

let b = new B(); // {text: 'A类私有的....'}
console.log(b);
console.log(b.hasOwnProperty('text')); // true

```

### 组合继承

```javascript
// 寄生组合式继承：原型式继承 + 借用构造函数继承
// 原型式继承：继承父类公有的
// 借用构造函数继承：继承父类私有的
// 寄生组合式继承最后把父类公有的变成子类公有的，把父类的私有的变成子类私有的。

function A () {
  // text 是 A 类实例私有的属性
  this.text = 'A类的私有text';
}

// say 方法是 A 类公有的方法
A.prototype.say = function () {
  console.log('hello world');
};

function B() {
  A.call(this); // 借用构造函数继承，继承父类私有的
}
B.prototype = Object.create(A.prototype); // 原型式继承，继承父类公有的
B.prototype.constructor = B; // 重新指定 B.prototype 中的 constructor

let b = new B();
console.log(b); // {text: 'A.....'}
console.log(b.text); // 继承的父类的私有属性 'A....'
b.say(); // say 是继承的公有属性 'hello world'
```

### 原型式继承：只继承子类公有的

```javascript
// 原型式继承：只继承父类公有的；

// 创建一个指定__proto__的对象
// Object.create(protoObj) 返回一个新对象，这个新对象的__proto__ 指向protoObj；
let obj2 = {
  name: '100',
  id: 17
};
let o2 = Object.create(obj2); // o2是新的对象，并且o2的__proto__属性指向obj2

function A() {
  this.text = 'A类私有的text';
}
A.prototype.say = function () {
  console.log('hello world');
};
A.prototype.getName = function () {
  console.log('北京不欢迎你们~');
};

function B() {
  // this.xxx = xxx
}

let obj = Object.create(A.prototype); // 创建一个对象obj，obj的__proto__指向A.prototype，obj不是A.prototype
// console.log(obj);

// 原型式继承：
B.prototype = obj; // obj -> {__proto__: A.prototype }
B.prototype.constructor = B; // 把B原型上的constructor属性改写成B；

B.prototype.getName = function () {
  console.log(this.name);
}; // obj -> {getName: function..., __proto__: A.prototype}

let b = new B(); // { __proto__: B.prototype }
console.log(b.text); // 通过这种方式继承，不能继承父类私有的
b.say(); // say是父类公有的方法，通过原型式继承可以继承

// b.say -> b的实例 {__proto__: B.prototype} -> b.__proto__ -> B.prototype(B.prototype现在是obj) -> obj { __proto__: A.prototype } -> obj.__proto__ -> A.prototype -> A.prototype.say
```

### 寄生组合式继承

```javascript
// 寄生组合式继承：原型式继承 + 借用构造函数继承
// 原型式继承：继承父类公有的
// 借用构造函数继承：继承父类私有的
// 寄生组合式继承最后把父类公有的变成子类公有的，把父类的私有的变成子类私有的。

function A () {
  // text是A类实例私有的属性
  this.text = 'A类的私有text';
}

// say方法是A类公有的方法
A.prototype.say = function () {
  console.log('hello world');
};

function B() {
  A.call(this); // 借用构造函数继承，继承父类私有的
}
B.prototype = Object.create(A.prototype); // 原型式继承，继承父类公有的
B.prototype.constructor = B; // 重新指定B.prototype中的constructor

let b = new B();
console.log(b); // {text: 'A.....'}
console.log(b.text); // 继承的父类的私有属性 'A....'
b.say(); // say是继承的公有属性 'hello world'
```

### 冒充对象继承

```javascript
// 冒充对象继承：在子类的构造函数中，创建一个父类的实例。遍历这个实例，把父类实例的属性都添加到子类的实例身上。

// 冒充对象继承：把父类公有和私有的都变成子类的私有的。
function A() {
  this.text = 'A类的私有属性text';
}

A.prototype.say = function () {
  console.log('hello world');
};

function B() {
  let a = new A(); // 创建A类的一个实例；{text: 'A类...'}
  for (let key in a) { // for in 循环遍历的是对象的可枚举属性，可枚举属性不仅包含对象私有属性，还包含当前对象所属类的原型上自定义的属性；
    this[key] = a[key];
  }
}
let b = new B();
console.log(b);


```