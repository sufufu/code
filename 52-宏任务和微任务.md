### 宏任务和微任务

+ 宏任务和微任务是等待任务对列中的异步任务的处理机制

- 首先浏览器会把主任务队列中的同步任务挨个全部执行完，然后再去等待任务队列中看哪个任务可以执行了，然后把该执行的任务放到主任务队列中去执行，等这个任务执行完，再去等待任务中看谁可以执行了，再把这个任务放到主任务队列中执行... 如此循环。这种循环叫做事件循环（Event Loop）
- 异步任务都是谁先到达条件谁先执行，但是谁先到达执行条件也有优先级的问题，这个优先级要看这个任务是宏任务还是微任务；微任务的优先级比宏任务的要高；

那些是微任务？？

1. Promise 的 then 的回调函数
2. async 函数 await 下面的代码
3. process.nextTick

那些是宏任务？？
定时器（setInterval 和 setTimeout）

```javascript
setTimeout(function () {
  console.log(1)
}, 0);

console.log(5);

let p = new Promise((resolve, reject) => {
  console.log(2);
  resolve(); // resolve 执行并不是让 then 里面回调函数立即执行，resolve 执行只是告诉 then 的回调函数到达执行条件了；而 then 里面的回调函数异步执行的，需要等着所有的同步任务执行结束才能执行它；
  console.log(3);
});

console.log(6);

p.then(() => {
  console.log(4)
});
console.log(7);

// 5 2 3 6 7 【主任务队列中的同步任务都执行完了】 4 1

// 为什么4先输出了？
// 因为定时器是宏任务，then 里面的回调函数是微任务；因为微任务的优先级比宏任务的高，所以微任务先执行；所以先输出4

// 当主任务队列中同步任务执行完，先去等待任务队列中把所有的微任务找到，并且执行这些微任务执行完；等微任务执行完，再去把宏任务找出来并且执行；

```

### async 和 await

async 和 await 是 es6 新增的关键字，用于把异步变同步

async 在函数定义时使用，用 async 定义的函数默认返回一个 promise 实例，可以直接 .then

```javascript
async function fx() {
  console.log(1);
}

let obj = {
  async getName () { // async 还可以定义对象的方法

  }
};
fx().then(() => { // 因为 async 函数返回了 Promise 实例，所以可以 .then
  console.log(2);
});

function g() {
  return 'abc';
}

function h() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('xyz');
    }, 3000)
  })
}
```

await（要和 async 一起使用）

```javascript
async function fn() {
  // await 等待，等它右侧的代码执行完；
  // await 用法：
  // let x = await g();
  // console.log(x);
  // 1. 如果 await 右侧是同步的代码，就会让同步代码执行；如果执行的是一个函数，还会把函数的返回值给到 await 左边的变量；
  
  let y = await h();
  console.log(y);
  console.log('123');

  // h().then((res) => console.log(res)) 有了 async 和 await，就不用写 then了；因为 await 可以取得 promise resolve 时传入的值

  // 2. 如果 await 右侧是一个 Promise 实例，或者一个方法返回了 Promise 实例，await 会等着 Promise 的实例 resolve，并且在实例 resolve 之前，await 后面的代码不执行；并且还会拿到 Promise 在 resolve 时传入的值，并且赋值给等号左侧变量；

  // 3. await 会把 await 下面的代码变成微任务；
}
fn();
```